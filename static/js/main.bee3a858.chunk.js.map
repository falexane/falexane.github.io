{"version":3,"sources":["slidingpuzzle/Logic.js","slidingpuzzle/components/Tile.js","slidingpuzzle/components/SlidingPuzzle.js","slidingpuzzle/App.js","index.js"],"names":["adjustInversions","array","length","swap","findIndexBlank","indexOf","makeSolvable","N","inversions","i","j","calcInversions","RowIndexOfBlank","indexOfBlank","Error","Math","floor","getRowIndexOfBlank","newPuzzle","Array","from","element","index","createSeries","shuffle","random","index1","index2","Tile","value","onClick","face","anchorStyle","tileStyle","isSolved","anchorRef","useRef","tileRef","useEffect","anchorRect","current","getBoundingClientRect","baseRect","parentNode","style","top","left","classList","remove","console","log","setTimeout","ref","className","edgeLength","SlidingPuzzle","n","useState","Logic","series","setSeries","indexBlank","boardStyle","width","height","fontSize","inverse","indexTarget","abs","last","map","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.bee3a858.chunk.js","sourcesContent":["const edgeLength = 300\r\nconst fontSizeBase =  12\r\n\r\nconst adjustInversions = (array) => {\r\n  const length = array.length\r\n  if (array[length - 1] === 0) swap(array, length - 2, length - 3)\r\n  else if (array[length - 2] === 0) swap(array, length - 1, length - 3)\r\n  else swap(array, length - 1, length - 2)\r\n}\r\n\r\nconst calcInversions = (array) => {\r\n  let inversions = 0\r\n  \r\n  for (let i = 0; i < array.length - 1; i++) {\r\n    if (array[i] === 0) continue\r\n    for (let j = i + 1; j < array.length; j++) {\r\n      if (array[j] !== 0 && array[i] > array[j]) inversions++\r\n    }\r\n  }\r\n  \r\n  return inversions \r\n}\r\n\r\n/**\r\n * Create an array of ascending numbers. It represents the data of a \"solved\" sliding puzzle with dimensions \"count x count\". e.g. For a 3x3 sliding puzzle it creates an array \"[1,2,3,4,5,6,7,8,0]\". The last \"0\" represent a blank cell. \r\n * @param {number} N the count of tiles per dimension\r\n * @returns {number[]} an array of numbers\r\n */\r\nconst createSeries = (N) => {\r\n  const length = N * N\r\n  const array = Array.from({length: length}, (element, index) => (index + 1) % length)\r\n\r\n  return array\r\n}\r\n\r\nconst easyPuzzle = (N) => {\r\n  switch (N) {\r\n    case 3:\r\n      // return [2, 3, 6, 1, 0, 5, 4, 7, 8]\r\n      return [1, 2, 3, 4, 5, 6, 0, 7, 8]\r\n    case 4:\r\n      return [5, 1, 7, 3, 9, 2, 11, 4, 13, 6, 15, 8, 0, 10, 14, 12]\r\n    case 5:\r\n      return [6, 1, 3, 4, 5, 11, 2, 7, 9, 10, 12, 17, 8, 13, 15, 18, 0, 23, 14, 19, 16, 21, 22, 24, 20]\r\n    default:\r\n      return [1, 2, 3, 4, 5, 6, 0, 7, 8]\r\n  }\r\n}\r\n\r\nconst findIndexBlank = (array) => {\r\n  return array.indexOf(0)\r\n}\r\n\r\nconst getRowIndexOfBlank = (array, N) => {\r\n  const indexOfBlank = array.indexOf(0)\r\n  if (indexOfBlank === -1) throw new Error('Invalid puzzle data')\r\n  return Math.floor(indexOfBlank / N)\r\n}\r\n\r\nconst isAdjacent = (index1, index2, N) => {\r\n  // console.log('[blank], [target], N ', index1, index2, N);\r\n  return (\r\n      ((index1 % N) === (index2 % N)) &&\r\n      (Math.abs(Math.floor(index1 / N) - Math.floor(index2 / N)) === 1)\r\n    ) || \r\n    (\r\n      (Math.floor(index1 / N) === Math.floor(index2 / N)) &&\r\n      (Math.abs((index1 % N) - (index2 % N)) === 1)\r\n    )\r\n}\r\n\r\nconst isSolved = (array) => {\r\n  const last = array.length -1\r\n  if (array[last] !== 0) return false\r\n  for (let i = last - 1;  i >= 0;  i--) {\r\n    if (array[i] !== i + 1) return false    \r\n  }\r\n  return true\r\n}\r\n\r\n/**\r\n * If N is odd, then puzzle instance is solvable if number of inversions is even in the input state. \r\n * If N is even, puzzle instance is solvable if the blank is on an even row counting from the bottom (second-last, fourth-last, etc.) and number of inversions is odd.\r\n * the blank is on an odd row counting from the bottom (last, third-last, fifth-last, etc.) and number of inversions is even.\r\n * @param {*} array \r\n */\r\nconst makeSolvable = (array, N) => {\r\n  const inversions = calcInversions(array)\r\n  // console.log('inversions = ', inversions)\r\n  // console.log('adjust...')\r\n  \r\n  if (N % 2 === 1) {\r\n    if (inversions % 2 === 1) adjustInversions(array)\r\n  } else {\r\n    const RowIndexOfBlank = getRowIndexOfBlank(array, N)\r\n    // console.log('RowIndexOfBlank = ', RowIndexOfBlank)\r\n    if (inversions % 2 === 1) {\r\n      if (RowIndexOfBlank % 2 === 1) adjustInversions(array)\r\n    } else {\r\n      if (RowIndexOfBlank % 2 === 0) adjustInversions(array)\r\n    }\r\n  }\r\n\r\n  // console.log('array = ', array)\r\n  // console.log('inversions = ', calcInversions(array))\r\n}\r\n\r\nconst newPuzzle = (N) => {\r\n  const array = createSeries(N)\r\n  shuffle(array)\r\n  // console.log('array = ', array)\r\n  makeSolvable(array, N)\r\n  return array\r\n}\r\n\r\n/**\r\n * Take Fisher-Yates Shuffle on an array\r\n * @param {Array} array\r\n * @returns {void}  \r\n */\r\nconst shuffle = (array) => {\r\n  for (let i = array.length - 1; i > 0 ; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1))\r\n    ;[array[i], array[j]] = [array[j], array[i]]\r\n  }\r\n}\r\n\r\nconst swap = (array, index1, index2) => {\r\n  [array[index1], array[index2]] = [array[index2], array[index1]]\r\n}\r\n\r\n\r\nexport {\r\n  edgeLength,\r\n  fontSizeBase,\r\n  createSeries, \r\n  calcInversions,\r\n  easyPuzzle,\r\n  findIndexBlank,\r\n  isAdjacent,\r\n  isSolved,\r\n  newPuzzle,\r\n  shuffle,\r\n  swap,\r\n}\r\n","import React, {useState, useEffect, useRef} from 'react'\r\nimport * as Logic from '../Logic'\r\n\r\nconst Tile = ({value, index, N, onClick, face, anchorStyle, tileStyle, isSolved}) => {\r\n  // const [index/* , setIndex */] = useState(props.index)\r\n  const anchorRef = useRef(null)\r\n  const tileRef = useRef(null)\r\n\r\n  useEffect(() => {\r\n    // const content = tileRef.current;\r\n    // content.style.position = \"absolute\";\r\n    const anchorRect = anchorRef.current.getBoundingClientRect()\r\n    const baseRect = anchorRef.current.parentNode.getBoundingClientRect()\r\n    // console.log(anchorRef.current.parentNode.className); // correct\r\n    // console.log('anchorRef top left: ', anchorRect.top, anchorRect.left);\r\n    // console.log(anchorRect.top, baseRect.top);\r\n    // console.log(anchorRect.left, baseRect.left);\r\n    tileRef.current.style.top = `${anchorRect.top - baseRect.top - 5}px`\r\n    tileRef.current.style.left = `${anchorRect.left - baseRect.left - 5}px`\r\n    // tileRef.current.style.width = `${anchorRect.width}px`\r\n    // tileRef.current.style.height = `${anchorRect.height}px`\r\n    // if (value === 0 && !isSolved) tileRef.current.style.opacity = 0\r\n    // if (value === 0 && isSolved) tileRef.current.style.opacity = 1\r\n    // if (value === 0) tileRef.current.style.opacity = (isSolved)? 1 : 0 // ok\r\n    if (value === 0 && isSolved) {\r\n      tileRef.current.classList.remove('invisible')\r\n      // tileRef.current.classList.add('invisible')\r\n      // tileRef.current.classList.remove('invisible')\r\n    }\r\n    if (value === 0 ) console.log('value, face, index, isSolved, tileStyle = ', value, face, index, isSolved, tileStyle);\r\n    if (isSolved) setTimeout(() => {\r\n      tileRef.current.style.top = `${anchorRect.top - baseRect.top - 80}px`\r\n    }, 800 + 100 * value)\r\n    if (isSolved) setTimeout(() => {\r\n      tileRef.current.style.top = `${Logic.edgeLength}px`\r\n    }, 1000 + 250 * value)\r\n  }/* , [index, N] */)\r\n\r\n/*   useEffect(() => {\r\n    console.log(`Tile[${index}] ${face} useEffect N=`, N);\r\n  }) */\r\n\r\n  return (\r\n    <div ref={anchorRef} className=\"anchor\" style={anchorStyle} \r\n      onClick={(onClick)? () => onClick(index) : null}>\r\n      <div ref={tileRef} className={(value === 0)? (isSolved)? \"tile\" : \"tile invisible\" : \"tile\"} style={tileStyle}>\r\n        {face}\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Tile\r\n","import React, {useState, useEffect, useRef} from 'react'\r\nimport Tile from './Tile'\r\nimport * as Logic from '../Logic'\r\n\r\nconst edgeLength = Logic.edgeLength\r\nconst fontSizeBase = Logic.fontSizeBase\r\n\r\nconst SlidingPuzzle = ({N = 3}) => {\r\n  // create number series of a 3x3 sliding puzzle by default\r\n  const n = useRef(N)\r\n  const [series, setSeries] = useState(Logic.newPuzzle(n.current))\r\n  const isSolved = useRef(false)\r\n  const indexBlank = useRef(Logic.findIndexBlank(series))  // caching\r\n\r\n  const boardStyle = {\r\n    width: `${edgeLength}px`, \r\n    height: `${edgeLength}px`\r\n  }\r\n  const anchorStyle = {\r\n    width: `${edgeLength / n.current}px`, \r\n    height: `${edgeLength / n.current}px`\r\n  }\r\n  const tileStyle = {\r\n    ...anchorStyle,\r\n    fontSize: `${fontSizeBase / n.current}rem`\r\n  }\r\n  \r\n  const easyPuzzle = () => {\r\n    // n.current = Math.floor(Math.random() * 3 + 3)  // [3 - 5]\r\n    n.current = 3\r\n    isSolved.current = false\r\n    setSeries(Logic.easyPuzzle(n.current))\r\n  }\r\n\r\n  const inverse = (indexTarget) => {\r\n    if (Logic.isAdjacent(indexBlank.current, indexTarget, n.current)) {\r\n      const array = Array.from(series)\r\n      Logic.swap(array, indexBlank.current, indexTarget)\r\n      if (Logic.isSolved(array)) isSolved.current = true\r\n      setSeries(array)\r\n    }\r\n  }\r\n\r\n  const newPuzzle = (N) => {\r\n    n.current = N\r\n    isSolved.current = false\r\n    setSeries(Logic.newPuzzle(N))\r\n  }\r\n\r\n  // update indexBlank\r\n  useEffect(() => {\r\n    // setIndexBlank(Logic.findIndexBlank(series))\r\n    indexBlank.current = Logic.findIndexBlank(series)\r\n  }, [series])\r\n\r\n/*   useEffect(() => {\r\n    console.log('SlidingPuzzle useEffect');\r\n  }) */\r\n\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"board\" style={boardStyle}>\r\n        {\r\n          series.map((value, index) => {\r\n            // const face =\r\n            return (\r\n              <Tile key={value} \r\n                value = {value}\r\n                index={index} \r\n                N={n.current} \r\n                onClick={(isSolved.current)? null : inverse} \r\n                face={(value === 0)? series.length : value} \r\n                anchorStyle={/* (value === 0)? {...anchorStyle, opacity: 0} : */ anchorStyle} \r\n                /* tileStyle={(value === 0)? {...tileStyle, opacity: 0} : tileStyle} */ \r\n                tileStyle={tileStyle} \r\n                isSolved={isSolved.current}\r\n              />\r\n              )\r\n          })\r\n        }\r\n      </div>\r\n      <div className=\"controls\">\r\n        <button onClick={() => {newPuzzle(3)}}>3 x 3</button>\r\n        <button onClick={() => {newPuzzle(4)}}>4 x 4</button>\r\n        <button onClick={() => {newPuzzle(5)}}>5 x 5</button>\r\n        <br/>\r\n        <button onClick={() => {easyPuzzle()}}>easy</button>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default SlidingPuzzle\r\n","import React, {useState, useEffect, useRef} from 'react'\r\nimport SlidingPuzzle from './components/SlidingPuzzle'\r\n// import * as Logic from './Logic'\r\nimport './App.css'\r\nimport './components/SlidingPuzzle.css'\r\n\r\n\r\nconst App = () => {\r\n  // create number series of a 4x4 sliding puzzle by default\r\n  // const [series, setSeries] = useState(Logic.newPuzzle(N))\r\n  // const n = useRef(N)\r\n  // const isSolved = useRef(false)\r\n  // const indexBlank = useRef(Logic.findIndexBlank(series))  // caching\r\n\r\n  // const [n, setN] = useState(N)\r\n  // const [indexBlank, setIndexBlank] = useState(/* Logic.findIndexBlank(series) */)\r\n\r\n  /* useEffect(() => {\r\n    setSeries(Logic.newPuzzle(n))\r\n  }, [n]) */\r\n\r\n\r\n/*   useEffect(() => {\r\n    console.log('App useEffect');\r\n  }) */\r\n\r\n/*   const easy = (N) => {\r\n    n.current = N\r\n    setSeries(Logic.easyPuzzle())\r\n  }\r\n\r\n  const newPuzzle = (N) => {\r\n    n.current = N\r\n    setSeries(Logic.newPuzzle(N))\r\n  }\r\n */\r\n  return (\r\n    <div className=\"App\">\r\n      <SlidingPuzzle />\r\n      {/* <div style={{width: 400, margin: 'auto'}}>\r\n        <button onClick={() => {newPuzzle(3)}}>3 x 3</button>\r\n        <button onClick={() => {newPuzzle(4)}}>4 x 4</button>\r\n        <button onClick={() => {newPuzzle(5)}}>5 x 5</button>\r\n        <br/>\r\n        <button onClick={() => {easy(3)}}>easy</button>\r\n      </div> */}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default App\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport App from './slidingpuzzle/App';\n// import reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  /* <React.StrictMode> */\n    <App />\n  /* </React.StrictMode> */,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}